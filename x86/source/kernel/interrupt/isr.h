#pragma once
#include "../../includes.h"


namespace MOSS { namespace Interrupts {


#define MOSS_INTERRUPT(MACRO)\
	MACRO(  0) MACRO(  1) MACRO(  2) MACRO(  3) MACRO(  4) MACRO(  5) MACRO(  6) MACRO(  7)   MACRO(  8) MACRO(  9) MACRO( 10) MACRO( 11) MACRO( 12) MACRO( 13) MACRO( 14) MACRO( 15)\
	MACRO( 16) MACRO( 17) MACRO( 18) MACRO( 19) MACRO( 20) MACRO( 21) MACRO( 22) MACRO( 23)   MACRO( 24) MACRO( 25) MACRO( 26) MACRO( 27) MACRO( 28) MACRO( 29) MACRO( 30) MACRO( 31)\
	MACRO( 32) MACRO( 33) MACRO( 34) MACRO( 35) MACRO( 36) MACRO( 37) MACRO( 38) MACRO( 39)   MACRO( 40) MACRO( 41) MACRO( 42) MACRO( 43) MACRO( 44) MACRO( 45) MACRO( 46) MACRO( 47)\
	MACRO( 48) MACRO( 49) MACRO( 50) MACRO( 51) MACRO( 52) MACRO( 53) MACRO( 54) MACRO( 55)   MACRO( 56) MACRO( 57) MACRO( 58) MACRO( 59) MACRO( 60) MACRO( 61) MACRO( 62) MACRO( 63)\
	MACRO( 64) MACRO( 65) MACRO( 66) MACRO( 67) MACRO( 68) MACRO( 69) MACRO( 70) MACRO( 71)   MACRO( 72) MACRO( 73) MACRO( 74) MACRO( 75) MACRO( 76) MACRO( 77) MACRO( 78) MACRO( 79)\
	MACRO( 80) MACRO( 81) MACRO( 82) MACRO( 83) MACRO( 84) MACRO( 85) MACRO( 86) MACRO( 87)   MACRO( 88) MACRO( 89) MACRO( 90) MACRO( 91) MACRO( 92) MACRO( 93) MACRO( 94) MACRO( 95)\
	MACRO( 96) MACRO( 97) MACRO( 98) MACRO( 99) MACRO(100) MACRO(101) MACRO(102) MACRO(103)   MACRO(104) MACRO(105) MACRO(106) MACRO(107) MACRO(108) MACRO(109) MACRO(110) MACRO(111)\
	MACRO(112) MACRO(113) MACRO(114) MACRO(115) MACRO(116) MACRO(117) MACRO(118) MACRO(119)   MACRO(120) MACRO(121) MACRO(122) MACRO(123) MACRO(124) MACRO(125) MACRO(126) MACRO(127)\
	MACRO(128) MACRO(129) MACRO(130) MACRO(131) MACRO(132) MACRO(133) MACRO(134) MACRO(135)   MACRO(136) MACRO(137) MACRO(138) MACRO(139) MACRO(140) MACRO(141) MACRO(142) MACRO(143)\
	MACRO(144) MACRO(145) MACRO(146) MACRO(147) MACRO(148) MACRO(149) MACRO(150) MACRO(151)   MACRO(152) MACRO(153) MACRO(154) MACRO(155) MACRO(156) MACRO(157) MACRO(158) MACRO(159)\
	MACRO(160) MACRO(161) MACRO(162) MACRO(163) MACRO(164) MACRO(165) MACRO(166) MACRO(167)   MACRO(168) MACRO(169) MACRO(170) MACRO(171) MACRO(172) MACRO(173) MACRO(174) MACRO(175)\
	MACRO(176) MACRO(177) MACRO(178) MACRO(179) MACRO(180) MACRO(181) MACRO(182) MACRO(183)   MACRO(184) MACRO(185) MACRO(186) MACRO(187) MACRO(188) MACRO(189) MACRO(190) MACRO(191)\
	MACRO(192) MACRO(193) MACRO(194) MACRO(195) MACRO(196) MACRO(197) MACRO(198) MACRO(199)   MACRO(200) MACRO(201) MACRO(202) MACRO(203) MACRO(204) MACRO(205) MACRO(206) MACRO(207)\
	MACRO(208) MACRO(209) MACRO(210) MACRO(211) MACRO(212) MACRO(213) MACRO(214) MACRO(215)   MACRO(216) MACRO(217) MACRO(218) MACRO(219) MACRO(220) MACRO(221) MACRO(222) MACRO(223)\
	MACRO(224) MACRO(225) MACRO(226) MACRO(227) MACRO(228) MACRO(229) MACRO(230) MACRO(231)   MACRO(232) MACRO(233) MACRO(234) MACRO(235) MACRO(236) MACRO(237) MACRO(238) MACRO(239)\
	MACRO(240) MACRO(241) MACRO(242) MACRO(243) MACRO(244) MACRO(245) MACRO(246) MACRO(247)   MACRO(248) MACRO(249) MACRO(250) MACRO(251) MACRO(252) MACRO(253) MACRO(254) MACRO(255)
#define ISR_ASM(N) extern "C" void isr##N##_asm(void);
MOSS_INTERRUPT(ISR_ASM)
#undef ISR_ASM


//Interrupt Service Routines ISRs are essentially callbacks.  They are called "interrupt vectors" and are stored in the IDT.  The
//CPU automatically calls an ISR for either interrupts or exceptions (faults, traps, and aborts).  That's what the following
//See http://www.brokenthorn.com/Resources/OSDev15.html.

//See http://wiki.osdev.org/Interrupts
//Exceptions are generated internally by the CPU.  They are the first 32 interrupt vectors.
//Interrupt Requests (IRQs)/Hardware Interrupts are generated externally by a chipset.
//	--An IRQ coming from a device enters the Programmable Interrupt Controller (PIC), which translates
//	  the IRQ into an interrupt vector.  The PIC sends an interrupt on that vector, notifying the CPU.
//	--To which interrupt vector the PIC translates the IRQ must be programmed.  By default, IRQs [0,7]
//	  correspond to interrupt vectors [8,15] and IRQs [8,15] correspond to interrupt vectors [112,119].
//	--Most computers actually have two PICs, handling 16 IRQs.
//	--IRQs have a priority.  Presumably only on systems with two PICs, the priorities run, decreasing:
//	  0, 1, 2, 8, 9, 10, 11, 12, 13, 14, 15, 3, 4, 5, 6, 7
//Software interrupts are generated by software with the "int" instruction.  Oft-used for system calls.
//They could technically be any interrupt vector.

//See Intel Manual, section 6.13.
//This error code works for all exceptions that push error codes except page faults (see note in section)
class ErrorCode { public:
	bool              external_event :  1; //1=The exception occurred during delivery of an event external to the program, such as an interrupt or an earlier exception.
	bool              descr_location :  1; //0=index refers to a descriptor in the GDT or LDT, 1=index refers to a gate descriptor in the IDT.
	bool                descr_in_LDT :  1; //Used iff descr_location=0.  0=index refers to descriptor in GDT, 1=index refers to segment/gate descriptor in LDT.
	uint16_t segement_selector_index : 13; //Current manual seems to imply this is the right size (the "upper half" is reserved, and it's 32 bits big altogether).  Confirmed by http://ftp.utcluj.ro/pub/users/nedevschi/PMP/protected86/protgemode/translate_c242.html.
	uint16_t                reserved : 16;
} __attribute__((packed));
//Page faults are special (see around pg. 285)
class ErrorCodePF { public:
	bool            P :  1; //Caused by 0=non-present page, 1=page-level protection violation
	bool           WR :  1; //Access causing fault was 0=read, 1=write
	bool           US :  1; //Access causing fault happened while running in 0=supervisor mode, 1=user mode
	bool         RSVD :  1; //0=The fault was not caused by reserved bit violation, 1=The fault was caused by reserved bits set to 1 in a page directory
	bool           ID :  1; //Whether the fault was caused by an instruction fetch
	uint32_t reserved : 27;
} __attribute__((packed));

//Exactly what the lower interrupts are is very inconsistent accross the web, and sources frequently
//disagree, especially about certain interrupts.  The authoritative source is treated to be the Intel
//Manual (http://www.intel.com/Assets/en_US/PDF/manual/253668.pdf, around page 233), listed along with
//mnemonic (if available) and type.  Where conflicting, other sources' input is listed on tab-indented
//lines below.

//One alternate source: http://www.osdever.net/bkerndev/Docs/isrs.htm

//"#DE": Fault: Divide Error (generated by "div", "idiv")
//No error code
//	Also divide by 0 exception
/*void isr0(void) {}

//"#DB": (Fault/Trap): RESERVED (for Intel use only)
//No error code
//	Debug exceptions/single step (debugger) (trap xor fault)  Error code: "None. Can be retrived from debug registers"; see http://www.brokenthorn.com/Resources/OSDev15.html.
void isr1(void) {}

//     : (Interrupt): NMI Interrupt (generated by a nonmaskable, external interrupt)
//No error code
//	Intel reserved/non-maskable interrupt (NMI) pin (unclassed/trap).
void isr2(void) {}

//"#BP": (Trap): Breakpoint (generated by "int $0x3")
//No error code
//	Breakpoint exception (debugger).
void isr3(void) {}

//"#OF": (Trap): Overflow (generated by "int0")
//No error code
//	Overflow/"Into detected overflow" (trap).
void isr4(void) {}

//"#BR": (Fault): BOUND Range Exceeded (generated by "bound")
//No error code
//	Bounds check/out of bound exception (trap/fault?).
void isr5(void) {}

//"#UD": (Fault): Invalid Opcode (Undefined Opcode) (generated by "ud2" (Pentium Pro+) or reserved opcode)
//No error code
//	Invalid/undefined opcode exception (trap/fault?).
void isr6(void) {}

//"#NM": (Fault): Device Not Available (No Math Coprocessor) (generated by a floating-point or "wait"/"fwait" instruction)
//No error code
//	Coprocessor not available/device not available exception (trap/fault?).
void isr7(void) {}

//"#DF": (Abort): Double Fault (generated by any instruction that can generate an exception, NMI, or an interrupt)
//Has error code (always 0)
void isr8(ErrorCode error) {}

//     : (Fault): Coprocessor Segment Overrun (reserved) (generated by a floating-point instruction)
//No error code
//Processors after the i386 do not generate this exception.
//	do not use (abort?/fault).
void isr9(void) {}

//"#TS": (Fault): Invalid TSS (generated by task switch or TSS access)
//Has error code
void isr10(ErrorCode error) {}

//"#NP": (Fault): Segment Not Present (generated by loading segment registers or accessing system segments)
//Has error code
void isr11(ErrorCode error) {}

//"#SS": (Fault): Stack-Segment Fault (generated by stack operations or "ss" register loads)
//Has error code
//	Stack fault exception/stack segment overrun (fault).
void isr12(ErrorCode error) {}

//"#GP": (Fault): General Protection (generated by any memory reference or other protection checks)
//Has error code
//	General protection exception/general protection fault/triple fault (fault xor trap).
void isr13(ErrorCode error) {}

//"#PF": (Fault): Page Fault (generated by any memory reference)
//Has error code
void isr14(ErrorCodePF error) {}

//     : (Unlisted): Intel reserved.  Do not use.
//No error code
//	Intel reserved?/unassigned.
void isr15(void) {}

//"#MF": (Fault): x87 FPU Floating-Point Error (Math Fault) (generated by x87 FPU floating-point or "wait"/"fwait" instruction)
//No error code
//	Coprocessor error/x87 FPU floating-point error (math fault) (fault).  No error code (x87 FPU provides own error information).
void isr16(void) {}

//"#AC": (Fault): Alignment Check (generated by any data reference in memory)
//Has error code (always 0)
//i486+ only
//	exception.
//	Different sources disagree about whether it has an error code.  E.g.
//		http://www.acm.uiuc.edu/sigops/roll_your_own/i386/idt.html says none
//		http://www.brokenthorn.com/Resources/OSDev15.html says there is one and it's always 0
//		The last post here: http://forum.osdev.org/viewtopic.php?f=1&t=23998&sid=98cd3b1e6b1256f0dbdb0885e84ba05f&start=15 mentions this issue.
void isr17(ErrorCode error);

//"#MC": (Abort): Machine Check (generation method(s) unlisted)
//No error code, although Intel manual implies that there may be error codes, and if so, that they are model-dependent.
//Introduced in Pentium, improved in P6 family
//	Machine check exception (Pentium/586+ only) (abort).  No error code (MSRs provide error information).
void isr18(void) {}

//"#XM": (Fault): SIMD Floating-Point Exception (generated by SSE/SSE2/SSE3 floating-point instructions).
//No error code
//Pentium III+ only
//	SIMD FPU exception (fault).
void isr19(void) {}

//     : (Unlisted): Intel reserved.  Do not use.
//Whether has error code is unlisted
void isr20through31(void);

//     : (Interrupt): User-Defined (Non-reserved) Interrupts (generated by external iterrupt or "int _" instruction)
//	TODO: do they pass error codes or not?
void isr32through255(void);*/

//When an ISR assembly callback is invoked, it jumps quickly to a common assembly subroutine, which then calls this C++ common handler.
//This function then delegates the event to the appropriate ISR C++ callback, above.  See isr.asm for more details.
/* This defines what the stack looks like after an ISR was running */

class State { public:
	uint32_t gs, fs, es, ds; //pushed the segs last
	uint32_t edi, esi, ebp, esp, ebx, edx, ecx, eax; //pushed by "pusha"
	uint32_t int_ind;
	uint32_t err_code; //One of the error code types.  Cast it.
	uint32_t eip, cs, eflags, useresp, ss; //pushed by the processor automatically
};
extern "C" void isr_common(State* state); //defined in isr.cpp; not assembly TODO: const


}}